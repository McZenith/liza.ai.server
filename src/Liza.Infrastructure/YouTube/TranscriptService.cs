namespace Liza.Infrastructure.YouTube;

using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;
using Liza.Core.Models;
using Liza.Core.Services;
using Microsoft.Extensions.Logging;

/// <summary>
/// YouTube transcript service with multiple extraction methods
/// Primary: Direct HTTP extraction (most reliable)
/// Fallback: YoutubeTranscriptApi library
/// </summary>
public class TranscriptService : ITranscriptService
{
    private readonly ILogger<TranscriptService> _logger;
    private readonly HttpClient _httpClient;

    public TranscriptService(ILogger<TranscriptService> logger, IHttpClientFactory? httpClientFactory = null)
    {
        _logger = logger;
        _httpClient = httpClientFactory?.CreateClient() ?? new HttpClient();
        _httpClient.DefaultRequestHeaders.Clear();
        _httpClient.DefaultRequestHeaders.Add("User-Agent", 
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
    }

    public async Task<TranscriptData?> GetTranscriptAsync(string videoId, string language = "en")
    {
        try
        {
            _logger.LogInformation("Fetching transcript for video {VideoId} (lang: {Language})", videoId, language);
            
            // Try HTTP-based extraction first (more reliable)
            var result = await TryHttpExtractionAsync(videoId, language);
            if (result != null) return result;
            
            // Fallback to library
            result = await TryLibraryExtractionAsync(videoId, language);
            if (result != null) return result;
            
            _logger.LogDebug("No transcript found for video {VideoId}", videoId);
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to get transcript for video {VideoId}", videoId);
            return null;
        }
    }

    private async Task<TranscriptData?> TryHttpExtractionAsync(string videoId, string language)
    {
        try
        {
            // Step 1: Get the video page to find caption tracks
            var videoUrl = $"https://www.youtube.com/watch?v={videoId}";
            var html = await _httpClient.GetStringAsync(videoUrl);
            
            // Step 2: Extract caption track URLs from ytInitialPlayerResponse
            var playerResponseMatch = Regex.Match(html, @"ytInitialPlayerResponse\s*=\s*(\{.+?\});", RegexOptions.Singleline);
            if (!playerResponseMatch.Success)
            {
                _logger.LogDebug("Could not find ytInitialPlayerResponse for {VideoId}", videoId);
                return null;
            }
            
            var playerJson = playerResponseMatch.Groups[1].Value;
            var playerDoc = JsonDocument.Parse(playerJson);
            
            // Navigate to captions
            if (!playerDoc.RootElement.TryGetProperty("captions", out var captions))
            {
                _logger.LogDebug("No captions property for {VideoId}", videoId);
                return null;
            }
            
            if (!captions.TryGetProperty("playerCaptionsTracklistRenderer", out var tracklist))
            {
                _logger.LogDebug("No tracklist for {VideoId}", videoId);
                return null;
            }
            
            if (!tracklist.TryGetProperty("captionTracks", out var tracks))
            {
                _logger.LogDebug("No caption tracks for {VideoId}", videoId);
                return null;
            }
            
            // Find the best matching track
            string? captionUrl = null;
            string actualLang = language;
            bool isAutoGenerated = false;
            
            foreach (var track in tracks.EnumerateArray())
            {
                var langCode = track.TryGetProperty("languageCode", out var lc) ? lc.GetString() : null;
                var baseUrl = track.TryGetProperty("baseUrl", out var bu) ? bu.GetString() : null;
                var kind = track.TryGetProperty("kind", out var k) ? k.GetString() : null;
                
                if (baseUrl == null) continue;
                
                // Prefer manual over auto-generated
                if (langCode == language || langCode?.StartsWith(language) == true)
                {
                    captionUrl = baseUrl;
                    actualLang = langCode ?? language;
                    isAutoGenerated = kind == "asr";
                    if (!isAutoGenerated) break; // Found manual, stop looking
                }
                else if (captionUrl == null && (langCode == "en" || langCode?.StartsWith("en") == true))
                {
                    // Fallback to English
                    captionUrl = baseUrl;
                    actualLang = langCode ?? "en";
                    isAutoGenerated = kind == "asr";
                }
            }
            
            if (captionUrl == null)
            {
                _logger.LogDebug("No suitable caption track for {VideoId}", videoId);
                return null;
            }
            
            // Step 3: Fetch the transcript XML
            // Add fmt=json3 to get JSON instead of XML
            var transcriptUrl = captionUrl + "&fmt=json3";
            var transcriptJson = await _httpClient.GetStringAsync(transcriptUrl);
            
            var transcriptDoc = JsonDocument.Parse(transcriptJson);
            
            if (!transcriptDoc.RootElement.TryGetProperty("events", out var events))
            {
                _logger.LogDebug("No events in transcript for {VideoId}", videoId);
                return null;
            }
            
            // Parse segments
            var segments = new List<TranscriptSegment>();
            
            foreach (var evt in events.EnumerateArray())
            {
                if (!evt.TryGetProperty("segs", out var segs)) continue;
                
                var startMs = evt.TryGetProperty("tStartMs", out var ts) ? ts.GetInt64() : 0;
                var durationMs = evt.TryGetProperty("dDurationMs", out var d) ? d.GetInt64() : 0;
                
                var text = new System.Text.StringBuilder();
                foreach (var seg in segs.EnumerateArray())
                {
                    if (seg.TryGetProperty("utf8", out var utf8))
                    {
                        text.Append(utf8.GetString());
                    }
                }
                
                var segText = text.ToString().Trim();
                if (string.IsNullOrEmpty(segText)) continue;
                
                segments.Add(new TranscriptSegment
                {
                    StartTime = startMs / 1000.0,
                    EndTime = (startMs + durationMs) / 1000.0,
                    Text = HttpUtility.HtmlDecode(segText)
                });
            }
            
            if (segments.Count == 0)
            {
                _logger.LogDebug("No segments parsed for {VideoId}", videoId);
                return null;
            }
            
            var fullText = string.Join(" ", segments.Select(s => s.Text));
            
            _logger.LogInformation("Got transcript via HTTP for {VideoId}: {SegmentCount} segments, {Length} chars", 
                videoId, segments.Count, fullText.Length);
            
            return new TranscriptData
            {
                VideoId = videoId,
                Language = actualLang,
                IsAutoGenerated = isAutoGenerated,
                FullText = fullText,
                Segments = segments
            };
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "HTTP extraction failed for {VideoId}", videoId);
            return null;
        }
    }

    private async Task<TranscriptData?> TryLibraryExtractionAsync(string videoId, string language)
    {
        try
        {
            var ytApi = new YoutubeTranscriptApi.YouTubeTranscriptApi();
            
            // Get available transcripts
            var transcriptList = await Task.Run(() => ytApi.ListTranscripts(videoId));
            
            YoutubeTranscriptApi.Transcript? transcript = null;
            bool isAutoGenerated = false;
            
            // Try to find manually created transcript first, then auto-generated
            try
            {
                transcript = transcriptList.FindTranscript(new[] { language, "en" });
                isAutoGenerated = transcript.IsGenerated;
            }
            catch
            {
                // Try generated transcripts
                try
                {
                    transcript = transcriptList.FindGeneratedTranscript(new[] { language, "en" });
                    isAutoGenerated = true;
                }
                catch
                {
                    return null;
                }
            }
            
            if (transcript == null) return null;
            
            // Fetch the transcript data
            var items = await Task.Run(() => transcript.Fetch());
            
            var segments = items.Select(item => new TranscriptSegment
            {
                StartTime = item.Start,
                EndTime = item.Start + item.Duration,
                Text = item.Text
            }).ToList();
            
            var fullText = string.Join(" ", segments.Select(s => s.Text));
            
            _logger.LogInformation("Got transcript via library for {VideoId}: {SegmentCount} segments", 
                videoId, segments.Count);
            
            return new TranscriptData
            {
                VideoId = videoId,
                Language = transcript.LanguageCode,
                IsAutoGenerated = isAutoGenerated,
                FullText = fullText,
                Segments = segments
            };
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Library extraction failed for {VideoId}", videoId);
            return null;
        }
    }
}
